

[
  
  
    
    
      {
        "title": "Linux上的free命令详解",
        "excerpt": "本文简要的说明Linux free命令中的buffer和cached是怎么回事。最近闲来无事，在应用服务器上执行了一下 free -m,出来下面的内容。\n\n",
        "content": "本文简要的说明Linux free命令中的buffer和cached是怎么回事。最近闲来无事，在应用服务器上执行了一下 free -m,出来下面的内容。\n\nfree -m\n\n            total       used       free     shared    buffers     cached\nMem:         15951      15647        303          0        323       9708\n-/+ buffers/cache:       5615      10335\nSwap:         4031         40       3991\n\n\n一看不对内存只剩303M，这是要死的节奏呀。于是乎上网查了一下此命令，才发现之前一直误解used、free这几个值的意思。\n\n\n  Mem这行是操作系统认为已使用和剩余的内存值\n  -/+ buffers/cache: 这个是实际使用的内存值\n  A buffer is something that has yet to be “written” to disk.\n  A cache is something that has been “read” from the disk and stored for later use.\n  buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。这二者是为了提高IO性能的,弥补快速的内存和磁盘之间的速度差。\n  当内存空间不够用的时候，会从buffer、cached中再拿回来，给对应的进程使用。\n\n\n参考：\n\nLinux上的free命令详解\n",
        "url": "/about-linux-free"
      },
    
      {
        "title": "java反射相关知识",
        "excerpt": "JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\n\n",
        "content": "JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\n\n\n  涉及到的类\n     java.lang.Class 、java.lang.reflect 包中相关的类，包括Constructor、Field、Method、Modifier\n获取Class的方法\n    Class 类十分特殊，它和一般类一样继承自Object。其实体用以表达Java程序运行时的classes和interfaces，也用来表达enum、array、primitive Java types（boolean, byte, char, short, int, long, float, double）以及关键词void。\n  获取类名的方法\n 每个类都继承于Object，通过Object的getClass方法获取，如new String().getClass(),这种用法要首先知道用的是哪个类再获取Class\n 利用Class.forName(className),这个是最常用的，可以通过类的全名获取类，之后再进行其它的反射操作。所有的反射操作都是基于Class来操作的。\n      @Test\n  public void testGetClass() throws ClassNotFoundException{\n      Class&lt;?&gt; s = Class.forName(\"proxyandreflection.Person\");\n      assertEquals(s.getName(),Person.class.getName());\n\t\t\n      Person person = new Person();\n      assertEquals(s.getName(),person.getClass().getName());\n  }\n\t\n  @Test(expected = RuntimeException.class)\n  public void testGetClassException(){\n      try {\n          Class.forName(\"Person\");\n      } catch (ClassNotFoundException e) {\n          throw new RuntimeException(e);\n      }\n  }\n    \n    getFields()\ngetMethods()\ngetField(String)\ngetDeclaredField()\ngetDeclaredFields()\ngetMethods()\ngetDeclaredMethods()\ngetMethod(String, Class&lt;?&gt;...)\ngetDeclaredMethod(String, Class&lt;?&gt;...)\n    \n    图中的方法都是反射编程中会用到的，其中每个方法基本上都有两个实现，有Declared及没有Declared的，如getFields getDeclaredFields,区别就是没有Declared的方法，只能获取public修饰的相关内容，而有Declared的方法则可以获取所有的相关内容不只是public的\n      /**\n   * 测试反射方法 getFields与getDeclaredFields的区别，其它Methods、Constructor也一样\n   * @throws ClassNotFoundException\n   */\n  @Test\n  public void test4Declared() throws ClassNotFoundException{\n      Class&lt;?&gt; s = Class.forName(\"proxyandreflection.Person\");\n      Field[] fields1 = s.getDeclaredFields();\n      Field[] fields2 = s.getFields();\n      assertNotEquals(fields1.length,fields2.length);\n\t\t\n      for(Field f1 : fields1){\n          System.out.print(Modifier.toString(f1.getModifiers())+\" \"+f1.getName()+\";\");\n      }\n      System.out.println();\n\t\t\n      for(Field f2 : fields2){\n          System.out.print(Modifier.toString(f2.getModifiers())+\" \"+f2.getName()+\";\");\n      }\n  }\n    \n  \n  对类进行实例化\n对于无参数构造函数直接调用s.newInstance()即可\n对于有参数的构造函数则要先调用getConstructor生成构造器，然后再操作\n    @Test\n  public void testInstance() throws Exception{\n      Class&lt;?&gt; s = Class.forName(\"proxyandreflection.Person\");\n      assertTrue(s.newInstance() instanceof Person);\n  }\n\t\n  @Test\n  public void testConstructor() throws Exception{\n      Class&lt;?&gt; s = Class.forName(\"interview.proxyandreflection.Person\");\n      Constructor&lt;?&gt; c = s.getConstructor(String.class);\n      Person person = (Person)c.newInstance(\"jackie\");\n      assertEquals(person.getName(),\"jackie\");\n  }\n    \n  \n  动态执行方法\n    @Test\n  public void testMethodInvoke() throws Exception{\n      Class&lt;?&gt; s = Class.forName(\"interview.proxyandreflection.Person\");\n      Object obj = s.newInstance();\n      Method setmethod = s.getDeclaredMethod(\"setMobileno\", String.class);\n      Method getmethod = s.getDeclaredMethod(\"getMobileno\");\n      setmethod.invoke(obj, \"jackie\");\n      assertEquals(getmethod.invoke(obj),\"jackie\");\n  }\n    \n  \n  \n    应用场景\n框架类应用为了适应各种需求，要动态处理大量的使用反射。\n  \n  缺点\n动态处理类、方法等的调用，难于跟踪调试\n反射包括了一些动态类型，所以JVM无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。\n我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。\n代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，降低可移植性。\n\n\n当然也不必过分担心，当反射代码被执行多次后，jvm会把它生成本地代码。\n",
        "url": "/about-java-reflection"
      },
    
  
  
  
  {
    "title": "About this website",
    "excerpt": "\n",
    "content": "I’m not sure yet what this website is about, but I’m sure I’ll work it out soon.\n",
    "url": "/about"
  },
  
  {
    "title": "Categories",
    "excerpt": "Category index\n",
    "content": "\n",
    "url": "/categories"
  },
  
  {
    "title": "Blog",
    "excerpt": "\n",
    "content": "\n",
    "url": "/blog/"
  },
  
  {
    "title": "Blog",
    "excerpt": "\n",
    "content": "There isn’t much going on here yet, but watch this space\n",
    "url": "/"
  }
  
]

