

[
  
  
    
    
      {
        "title": "Linux上的free命令详解",
        "excerpt": "本文简要的说明Linux free命令中的buffer和cached是怎么回事。最近闲来无事，在应用服务器上执行了一下 free -m,出来下面的内容。\n\n",
        "content": "本文简要的说明Linux free命令中的buffer和cached是怎么回事。最近闲来无事，在应用服务器上执行了一下 free -m,出来下面的内容。\n\nfree -m\n\n            total       used       free     shared    buffers     cached\nMem:         15951      15647        303          0        323       9708\n-/+ buffers/cache:       5615      10335\nSwap:         4031         40       3991\n\n\n一看不对内存只剩303M，这是要死的节奏呀。于是乎上网查了一下此命令，才发现之前一直误解used、free这几个值的意思。\n\n\n  Mem这行是操作系统认为已使用和剩余的内存值\n  -/+ buffers/cache: 这个是实际使用的内存值\n  A buffer is something that has yet to be “written” to disk.\n  A cache is something that has been “read” from the disk and stored for later use.\n  buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。这二者是为了提高IO性能的,弥补快速的内存和磁盘之间的速度差。\n  当内存空间不够用的时候，会从buffer、cached中再拿回来，给对应的进程使用。\n\n\n参考：\n\nLinux上的free命令详解\n\n\n\n\n\n",
        "url": "/about-linux-free"
      },
    
      {
        "title": "java反射相关知识",
        "excerpt": "JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\n\n",
        "content": "JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\n\n\n  涉及到的类\n     java.lang.Class 、java.lang.reflect 包中相关的类，包括Constructor、Field、Method、Modifier\n获取Class的方法\n    Class 类十分特殊，它和一般类一样继承自Object。其实体用以表达Java程序运行时的classes和interfaces，也用来表达enum、array、primitive Java types（boolean, byte, char, short, int, long, float, double）以及关键词void。\n  获取类名的方法\n 每个类都继承于Object，通过Object的getClass方法获取，如new String().getClass(),这种用法要首先知道用的是哪个类再获取Class\n 利用Class.forName(className),这个是最常用的，可以通过类的全名获取类，之后再进行其它的反射操作。所有的反射操作都是基于Class来操作的。\n      @Test\n  public void testGetClass() throws ClassNotFoundException{\n      Class&lt;?&gt; s = Class.forName(\"proxyandreflection.Person\");\n      assertEquals(s.getName(),Person.class.getName());\n\t\t\n      Person person = new Person();\n      assertEquals(s.getName(),person.getClass().getName());\n  }\n\t\n  @Test(expected = RuntimeException.class)\n  public void testGetClassException(){\n      try {\n          Class.forName(\"Person\");\n      } catch (ClassNotFoundException e) {\n          throw new RuntimeException(e);\n      }\n  }\n    \n    getFields()\ngetMethods()\ngetField(String)\ngetDeclaredField()\ngetDeclaredFields()\ngetMethods()\ngetDeclaredMethods()\ngetMethod(String, Class&lt;?&gt;...)\ngetDeclaredMethod(String, Class&lt;?&gt;...)\n    \n    图中的方法都是反射编程中会用到的，其中每个方法基本上都有两个实现，有Declared及没有Declared的，如getFields getDeclaredFields,区别就是没有Declared的方法，只能获取public修饰的相关内容，而有Declared的方法则可以获取所有的相关内容不只是public的\n      /**\n   * 测试反射方法 getFields与getDeclaredFields的区别，其它Methods、Constructor也一样\n   * @throws ClassNotFoundException\n   */\n  @Test\n  public void test4Declared() throws ClassNotFoundException{\n      Class&lt;?&gt; s = Class.forName(\"proxyandreflection.Person\");\n      Field[] fields1 = s.getDeclaredFields();\n      Field[] fields2 = s.getFields();\n      assertNotEquals(fields1.length,fields2.length);\n\t\t\n      for(Field f1 : fields1){\n          System.out.print(Modifier.toString(f1.getModifiers())+\" \"+f1.getName()+\";\");\n      }\n      System.out.println();\n\t\t\n      for(Field f2 : fields2){\n          System.out.print(Modifier.toString(f2.getModifiers())+\" \"+f2.getName()+\";\");\n      }\n  }\n    \n  \n  对类进行实例化\n对于无参数构造函数直接调用s.newInstance()即可\n对于有参数的构造函数则要先调用getConstructor生成构造器，然后再操作\n    @Test\n  public void testInstance() throws Exception{\n      Class&lt;?&gt; s = Class.forName(\"proxyandreflection.Person\");\n      assertTrue(s.newInstance() instanceof Person);\n  }\n\t\n  @Test\n  public void testConstructor() throws Exception{\n      Class&lt;?&gt; s = Class.forName(\"interview.proxyandreflection.Person\");\n      Constructor&lt;?&gt; c = s.getConstructor(String.class);\n      Person person = (Person)c.newInstance(\"jackie\");\n      assertEquals(person.getName(),\"jackie\");\n  }\n    \n  \n  动态执行方法\n    @Test\n  public void testMethodInvoke() throws Exception{\n      Class&lt;?&gt; s = Class.forName(\"interview.proxyandreflection.Person\");\n      Object obj = s.newInstance();\n      Method setmethod = s.getDeclaredMethod(\"setMobileno\", String.class);\n      Method getmethod = s.getDeclaredMethod(\"getMobileno\");\n      setmethod.invoke(obj, \"jackie\");\n      assertEquals(getmethod.invoke(obj),\"jackie\");\n  }\n    \n  \n  \n    应用场景\n框架类应用为了适应各种需求，要动态处理大量的使用反射。\n  \n  缺点\n动态处理类、方法等的调用，难于跟踪调试\n反射包括了一些动态类型，所以JVM无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。\n我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。\n代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，降低可移植性。\n\n\n当然也不必过分担心，当反射代码被执行多次后，jvm会把它生成本地代码。\n\n\n\n\n\n",
        "url": "/about-java-reflection"
      },
    
      {
        "title": "ArrayList线程安全引起数组越界问题",
        "excerpt": "ArrayList不是线程安全的，那么如果用在多线程中会出现什么问题呢，下面的问题是在工作中踩的一个坑。\n\n",
        "content": "ArrayList不是线程安全的，那么如果用在多线程中会出现什么问题呢，下面的问题是在工作中踩的一个坑。\n\n  List&lt;Object&gt; list = new ArrayList&lt;&gt;();\n  stocklist.stream().forEach(stock-&gt;{\n    ticket = api.getTicket(stock);\n    list.add(ticket);\n  });\n\n\n某天同事觉得这段代码跑得有点慢，就把stream换成parallelStream,结果就报如下错误：\n\n Exception in thread \"Thread-1\" Exception in thread \"Thread-2\" java.lang.ArrayIndexOutOfBoundsException: 15\n     at java.util.ArrayList.elementData(ArrayList.java:418)\n     at java.util.ArrayList.get(ArrayList.java:431)\n     at java.lang.Thread.run(Thread.java:745)\n java.lang.ArrayIndexOutOfBoundsException: 15\n     at java.util.ArrayList.add(ArrayList.java:459)\n     at java.lang.Thread.run(Thread.java:745)\n\n\n分析：\n\nArrayList是基于数组实现的，数组长度是固定的，当元素达到数组上限时容量就要自动增长。\nadd实现方法如下，首先检查数组长度是否可以再添加一个元素，如果不满足就扩容后添加此元素，然后再复制数组。\n\n\n    public boolean add(E e) {\n        ensureCapacityInternal(size + 1); \n        elementData[size++] = e; //数组赋值\n        return true;\n    }\n    \n    private void ensureExplicitCapacity(int minCapacity) {\n            modCount++;\n    \n            // overflow-conscious code\n            if (minCapacity - elementData.length &gt; 0)\n                grow(minCapacity);\n        }\n\n\n由于ArrayList是线程不安全的，假设当前数组容量是15，当前size=14\n\n\n  \n    \n      序号\n      线程1\n      线程2\n    \n  \n  \n    \n      1\n      add\n      add\n    \n    \n      2\n      数组赋值 elementData[14]=e\n       \n    \n    \n      3\n       \n      数组赋值 elementData[15]=e\n    \n    \n      4\n       \n      ArrayIndexOutOfBoundsException\n    \n  \n\n\n可以看到第1步线程1和2都认为不需要扩容，线程1先执行add这时size=15数组已满无法再添加元素，而线程2执行第三步时自然就越界了。\n\n解决办法\n\n明白问题所在，解决办法就好弄了\n\n  list.add(ticket); 加上锁\n  把ArrayList换成CopyOnWriteArrayList\n\n\n\n\n\n\n",
        "url": "/arraylist-threadsafe-ArrayIndexOutOfBoundsException"
      },
    
      {
        "title": "MySQL 碎碎念",
        "excerpt": "mysql MDL读锁\n\n",
        "content": "mysql MDL读锁\n\n\n  MDL锁（metadata lock），用来保护表的元数据信息，主要用于解决或者保证DDL操作与DML操作之间的一致性。\n  sessionA的CRUD会加上MDL读锁，而sessionB的DDL加MDL写锁，要等前面所有的锁释放完才能轮到DDL操作，后面所有此表的操作都会被阻塞。\n  参考文章\n\n\nRR隔离级别下快照时间\n\n  RR隔离级别下，事务执行过程中当遇到第一个普通读后，整个事务就开始使用当前最新的快照，这个快照是针对所有的表，而不是你读操作的表\n\n\n\n  \n    \n      序号\n      事务A\n      事务B\n    \n  \n  \n    \n      1\n      select * from A\n       \n    \n    \n      2\n       \n      update B set b=5 where id = 6\n    \n    \n      3\n      select * from B where id = 6\n       \n    \n    \n      4\n      select * from B where id = 6\n       \n    \n  \n\n\n\n  事务A中第3步读到的数据仍然是B更新前的数据\n  事务A中第4步由于是当前读所以可以读到最新数据\n\n\n当前读与幻读\n\n  MySQL当前读(如for update等)在RR隔离级别下也会读到其它事务提交的数据，所以可能产生幻读。\n  普通读由于读取的都是快照数据，所以不会产生幻读的情况\n  参考文章\n\n\n主键锁\n\n  MySQL主键锁并不是事务锁，申请完就释放\n  对于 insert  into select 这种类型的，要在事务结束后才释放，因为不知道有多少条，申请方式是按次申请，每次条数为  2的(n-1)方，所以可能产生id不连续。\n\n\n\n\n\n\n",
        "url": "/MySQL-suisuinian"
      },
    
  
  
  
  {
    "title": "About this website",
    "excerpt": "\n",
    "content": "I’m not sure yet what this website is about, but I’m sure I’ll work it out soon.\n",
    "url": "/about"
  },
  
  {
    "title": "Categories",
    "excerpt": "Category index\n",
    "content": "\n",
    "url": "/categories"
  },
  
  {
    "title": "Blog",
    "excerpt": "\n",
    "content": "\n\n\n\n",
    "url": "/blog/"
  },
  
  {
    "title": "Blog",
    "excerpt": "\n",
    "content": "There isn’t much going on here yet, but watch this space\n\n\n\n\n\n\n",
    "url": "/"
  }
  
]

